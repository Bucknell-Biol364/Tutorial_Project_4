---
title: "Group Project 4"
subtitle: "Biology 368/664 Bucknell University"
output: html_notebook
author: "Abby, Irene, and Sam"
date: 9 Feb 2022
---

## Target Audience
Discuss with your group the target audience for the tutorial. 
Examples could be one of the new core Biology classes, another 300-level course (not 364), or a research group. 

```{r echo=FALSE}

```

## Grading

Each student will be expected to complete the following tasks to earn 85% of the points available for this assignment (21/25).

- Identify and obtain suitable dataset
- Use a Github repository and version control to collaborate on the project
- Spend 4-6 hours preparing, coding, and testing tutorial
  + Data exploration: Sam
  + Data visualization: Irene 
  + Hypothesis testing: Abby 
- Present tutorial in class
- Provide public archive suitable for sharing to students/faculty

Tutorials from previous classes can be viewed at our public github site: https://github.com/Bucknell-Biol364

Each group should use an *Acknowledgements* section to document the participation of each member and the collaboration within and between groups.

Additional credit will be awarded for providing assistance to other groups and for the development of a tutorial that goes beyond the minimal expectations listed above.

#Introducing R

*What is R?* 
R is a programming language that is used to manipulate, visualize, and interpret data. 
R is specifically designed to manipulate large data set and to visualize those data sets in a way that can be used to gather conclusions. It is free to download, making it very accessible to anyone who wants to use it. Currently, R is the industry standard for data science in biology. 

*Introduction to R Studio *
The display screen of R Studio is split into 4 different quadrants, each of which has a different purpose. 

R Script: the upper left window. This is where you will spend the most time in R as it's where you will write your code. 

R Consule: the bottom left window. This is where the program R is actually running. You are also able to write code directly in the console, but there is no way to edit the code you put there after you run it. Generally it's best to write any code in the script so then you have the ability to change it later. 
The console is also where error messages appear. These messages will be usable, in conjunction with other sources as such as Google, in determining the mistakes you made in your code. 

R Environment: the upper right window. This shows a record of all of the objects you currently have saved in R. So any variables, data frames, or variables you have will be shown here. 

R graphical output/files/packages: the bottom right screen. This window has many different functions. Here, you can navigate through your computer and locate files to load into R. The plots tab also allows you to look at any graphs you created. Lastly, the package tab is one way you'll be able to load different packages into R.

*Writing commands in R* 
Writing code is how you'll get anything done in R, so it's best to learn how to do so first. 

The section above said that you write code in the R script window, but the text you're currently reading isn't code. We are currently using a R Markdown file, where the default text is not considered code. 

To write a line of code that R will try to run, you must use a code chunk. Anything that isn't within a code chunk will just be considered text and ignored by R, but R will try to run anything that is within a code chunk. 

Creating Code Chunks 
There are many wasy to create a code chunk. 

1) Use the create code chunk button on the top of the screen (a green C with a plus sign). This will automatically add a chunk wherever your mouse is currently in the script. When you use this, chose the default R option. 

2) creating one manually. You can type in the symbols that indicate a code chunk by yourself. The start of a chunk is is designated by three backticks (```) followed by a set of curly brackes ({}). On the next time, add three additional bacticks to designate the end of a code chunk. The code you want to run should go in between. 
```{r a code chunk}

```
You may also name your code chunks something more specific by adding more wording following the r in the curly brackets. But be warned, if you are going to name your code chunks, know that each code chunk must have a unique name or else R may run into problems.

Adding Comments 
What if you want to add a line of text code within a code chunk that isn't code? You can add comments by prefacing them with a # symbol. This tells R that the text following # is not meant to be run. 

Run the code below and see what output is given.
```{r Hello World}
print("Hello World")
#this code will return the phrase "Hello World" bock to you. 
```
Notice how the print command was the only thing that run in that code chunk. The words following # are ignored. 

*Packages in R*
You can use R just by writing code into the console, which will work just fine; however, it is much more useful to use packages. Packages are collections of code, functions, and data sets that make R easier to use. 

Loading in packages 
There are many ways to load packages, but the annoying thing is that a packages must be both installed in computer and then loaded onto your specific document. Even if you already installed a package, you will have to load the same package for every new R markdown you create. 

First is just by using the package tab in the bottom right screen. 

The second method is by writing code that specifically loads the package. This method is preferred; if you were to share your code with anyone, they would be able to use the same packages you installed because you added code to do that. 

Let's do any example of loading in some packages right now. 

Here, we're loading the package "cowplot", which is used to create neater, more uniform looking graphs. 
```{r Load Libraries, include=FALSE}
if (!require("cowplot")) install.packages("cowplot"); library(cowplot)
```
This code looks complicated, but let's break it down. 
`if (!require("cowplot")) install.packages("cowplot")` tells R to see see if "cowplot" is already installed in your computer. If it's not installed, then it tells R to do so. 
Next, `library(cowplot)` tells R to load cowplot on your current work space. 



To load different packages, type in the name of you package you want to use.
So, here, we're loading in the package "tidyverse", which contains a whole host of useful packages used to help manipulate and visualize data 
```{r Load Libraries, include=FALSE}
if (!require("tidyverse")) install.packages("tidyverse"); library(tidyverse)
```
Notice how you only have to replace the name of the package. So here, the word tidyverse replaced every instance of the the word cowplot. Keep the format the same - keep the quotation marks where they already are but keep them off where they aren't needed. 

Try loading in the package "ggplot2", which is used to help make graphs 
```{r}
```

In this tutorial, we're going to be looking at 


This is an updated and expanded version of the mammals sleep dataset. Updated sleep times and weights were taken from V. M. Savage and G. B. West. A quantitative, theoretical framework for understanding mammalian sleep. Proceedings of the National Academy of Sciences, 104 (3):1051-1056, 2007.
http://www.pnas.org/content/104/3/1051.abstract

#Data exploration 

You can view the data in table form to see if it imported correctly 
*Just type the name of the data set*
```{r summary}

```
Then you can look at the summary of the whole datasheet. This can be done with the summary command. 

*summary(dataset) allows you to look at the summary of the data*
```{r summary 2}

```

The summary command is very powerful in that it provides the basics of the data. It tells you what each variable type (mode) is labled as (character, numeric, integer, complex, or logical). It also provides you with each variables name, number of data points, mean, median, min, max, 1st quartile, and 3rd quartile. 

Sometimes the mode that R picks for the data needs to be changed. 

*new name <- as.character(dataset$variable)* 
*You can check it worked with mode(new name)*
```{r as.character}

```

For this specific variable it would be useless to change the mode but sometimes you will run into situations where it is necessary, so always check the class and mode of your variables. 

Now that the whole data set has been seen you can now begin to look at different variables.  

*table(dataset$variable)*
```{r one variable}

```

or you could view tables with 2 variables against each other 

*table(dataset$varible1, dataset$variable2)*
```{r 2 variables}

```

A hypothesis to test for this data is, total sleep depends on body weight. 

For the hypothesis we are looking at body weight so we can look at a box plot of the data. Type the command below.

*ggplot(msleep) + aes(x = bodywt) + geom_histogram() + theme_cowplot()*
```{r normality}

```

From this box plot we can see the normality of the data. It is important that the data be distributed normally because for statistical tests you will see later many assume the data is normal.

We can see here that the data is not distrusted normally, so we can try and transform the to become normally distrusted. 

Try making a histogram of body weight but this time try doing a log transformation. 

*Type the same command as before but this time for x type log(bodywt)*
```{r log transform}

```

The data was made more normal from a log10 transformation. Sometimes the data cannot be transformed to become normal and that is okay. Just make a note when doing a statistical test that the data was not distributed normally.

If you had a more specific hypothesis and wanted to look at a more specific range within the variable you could do that. Maybe you wanted to only look at the brain weights were the body weight was below 100.

*new name <- filter(msleep, (bodywt <= 100))*
*ggplot(new name) + aes(x = log(brainwt)) + geom_histogram() + theme_cowplot()*
```{r filter}

```

If you needed, you could do multiple data filters for different variable at the same time. Just make sure to give the filtered data a good name. Sometimes you can end up with a lot of different names, so stay organized. Also you never want to name something the same as the name of the data set because R will overwrite the data with your filtered data. 

When you explore the data enough you can then move onto truly visualizing it. 
 

#Data visulization 

Though you've already seen some graphs displayed, here we'll show you how to create graphs in some more depth. Specifically, we will use the package ggplot2 to do so.
We'll at the distribution of some of the key variables we're looking at, such as body weight and and sleep total. 

*One variable graphs*
*
Let's first start with the histogram you already saw in the previous section exploring the distribution of body weight. 
```{r histogram for body weight}
ggplot(msleep) +
  aes(x=bodywt)+
  geom_histogram()
```
Let's break this down a bit.
The function ggplot is very diverse and can be used to create many,many plots, but it has some specific parameters that you must use for it to work. The above code shows the bare minimum you need to use ggplot. Many more additional parameters can be called to change the graph. 

(Note that there are many different format you can use to utilize ggplot, and this tutorial will only show you one method)

*Basic Elements of ggplot:*
1) ggplot(), this calls the function ggplot. Within the parenthesis is where you should call the dataframe you are using. This tells R to use that dataframe when creating the graph. 

2) aes(), this controls the "aesthetics" of the graph, or which variables in the data should be used where. So here, you would tell R which x and y variable you're using ( and possibly which variable you cant to group by if that's your analysis). In the example above, only the x variable is specified as the variable bodywt. The y variable is left unspecified in this case, which means R will use count ( or the total number of individual) as the y variable. 
(Note that you don't need to use parenthesis here, "bodywt", since you already specified msleep as the dataframe. So R will look within the dataframe msleep for a variable called bodywt.)

3) geom_historgram(), this tell R which specific graph you want to create. Because we're looking at a distribution of only one variable, we're using a histogram. You can, however, use serval other graphs - geom_boxplot, geom_point (for a scatterplot), and more. 
(A list of some of the different plots you can make are listed here: https://ggplot2.tidyverse.org/reference/)


But we can add some additonal features/change some features of our graph. 
Let's redo this same histogram, but this time 1) clean up the histogram, 2) clean it up the background, and 3)change the axes labels. 
```{r improved histogram for body weight}
ggplot(msleep) +
  aes(x=bodywt)+
  geom_histogram(bins=50, color="black",fill="grey")+
  labs(x="Body Mass (kg)",y="Number of Individuals")+
  theme_cowplot()
```
1) Cleaning up the graph: 
Here, three things were changed: the outline of the bars, the color of the bars, and the size of each bar. 
- `bins=50` changed the size of each bar. To be more technical, this code changed the number of bins used. A bin is a a group of data. The default is bin=30, but by changing that to a large number we are able to see a bit of the graph as a whole. You will not always have to change the bin number, but the previous graph gave a suggestion to change the bin number. 
- `color="black"` changed the outline of the histogram to the color black. You can specify the name of basic colors within quotations. 
- `fill="grey"`, this changed the color the histogram.

2) Cleaning up the Background 
The grey and white grid mas removed and axis lines were added. This is all courtesy of the command `theme_cowplot()` which applies all these changes in one command. 

3) Changing the Axes Names 
A new section `labs()` was added. This stands for labels, and you can change the label names of anything you specify. So to change the x axis label, you would use `x="New Name"`. The same logic would apply to the y axis label. Here, you will need to specificy the name is quotation marks. 

So the general format for 
`ggplot(Dataframe) + aes(x=xvariable,y=yvariable)+ geom_histogram(bins=#, color="color",fill="color") + labs(x="X Label",y="Y Label")+ theme_cowplot()` 

You can also look at the log transformed data of body weight, since we know that body weight is not noramlly distributed
```{r improved histogram for body weight}
ggplot(msleep) +
  aes(x=log(bodywt))+
  geom_histogram(bins=40, color="black",fill="grey")+
  labs(x="Log Body Mass (kg)",y="Number of Individuals")+
  theme_cowplot()
```

Create a histogram for the variable brainwt The base code is provided, but you'll have to add the specifics. Keep in mind that you may also have to transform the variable. 
```{r your graph for histogram for brainwt}
ggplot() +
  aes()+
  geom_histogram()
```
*Histograms of Categorical Variables*
You can also use histograms for categorical variables, such as the variable vore (which states which "vore" an animal is).

The code for this is very similiar as for quantitative variables, but there are some key changes.
```{r transformed histogram for body weight}
ggplot(msleep) +
  aes(x=vore)+
  geom_bar (color="black",fill="grey")+
  labs(x="Type of Feeder",y="Number of Individuals")+
  scale_x_discrete(labels = c('Carnivore','Herbivore','Insectivore',"Omnivore","NA"))+
  theme_cowplot()
```
The most important change to note the change of geom_histogram to geom_bar.
Histograms are used to show continuous, quantitative data wheres bar graphs are used to show the counts ( which is perfect for categorical variables.)

An explanation to change the factors names on the graph: 
`scale_x_discrete(labels = c('Carnivore','Herbivore','Insectivore',"Omnivore","NA"))` was used to change the names. The `c()` is the concatenate function, which is used to combine a list of things. 
You must list out the new names you want in the order that you want it in. R will take that list of names and replace it exactly as you have it listed. So the list name will go to the first graph bar in the graph, the second name to the third name, and so on and so forth. Make sure that you the number of names you have matches the number of things you want to change. 

*Looking at more than one variable*

*Quantitative vs quantitative variable*
To look at the distribution of two quantitative variables, use a scatter plot.
```{r boxplot of vore and sleep_total}
ggplot(msleep) +
  aes(x=log(bodywt),y=sleep_total)+
  geom_smooth()+
  geom_point()+
  labs(x="Log Body Mass (kg)",y="Total Sleep (hrs)")+
  theme_cowplot()
```
To use a scatterplot, use `geom_point`, which plots points on the graph. The additonal code `geom_smooth` will add a regression line on the point as well as a 95% confidence interval. 

*Categorical vs. quantitative variable* 
To look at the distribution of a quantitative variable for the different levels of a categorical variables, use a box plot. 
```{r boxplot of vore and sleep_total}
ggplot(msleep) +
  aes(x=vore,y=sleep_total)+
  geom_boxplot()+
  labs(x="Type of Feeder",y="Total Sleep (hrs)")+
  scale_x_discrete(labels = c('Carnivore','Herbivore','Insectivore',"Omnivore","NA"))+
  theme_cowplot()
```
The basic commands for ggplot remain largely unchanged, expect now you have to call `geom_boxplot` instead of `geom_histogram`. 
Also, because you are looking at more than one variable, you must specify a x and y variable. 

*Filtering using Dplyr to Isolate Variable* 
But what if you only want to look at a couple of factors within a categorical variables. Like for example, you want to look at whether the body mass of carnivores differs significantly from that of herbivores. 

One way to do this is create a create a new data frame which only those factor you want to look at. To do this, we can use the dplyr package (which is included in the tidyverse package) and specifically the filter function. 

First, we'll start with some practice isolating factors.

```{r isolating factors}
dplyr::filter(msleep, vore =="carni" )
```
Here we use the filter command in dplyr to isolate only the animals that are carnivores. We bust specify the data frame we're looking at as well as the logical argument.

Here are some common logical statments
      Symbol          Meaning 
        <             is less than 
        <==           is less than or equal to
        >             is greater than 
        >==           is greater than or equal to
        ==            is equal to 
        !=            is not equal to
        |             or 
        &             and

Try isolating only the herbivores.
```{r isolating herbivores}
```


But how does this help us create a boxplot of only the herbivores and the carnivores?

Let's create a new dataframe with only those animals. 
```{r creating a new dataframe for carnivore and herbivores}
CarniHerbi <- dplyr::filter(msleep, vore =="carni" | vore =="herbi")
```

There's a lot to break down here. 
Firstly, we are creating a new data frame called CarniHeri. This is specificed by the arrow sign, which points to the the name of the new data frame but starts at what that that dataframe will contain. 

To create this new dataframe, R will use the dataframe msleep.
In this dataframe CarniHerbi, there only contain animals who are carnivore or herbivores. The `|` is a logical statement which means "or". 


Now let us create a boxplot of the body mass of only carnivores and herbivores.
```{r boxplot of select vore and body mass}
ggplot(CarniHerbi) +
  aes(x=vore,y=log(bodywt))+
  geom_boxplot()+
  labs(x="Type of Feeder",y="Body Mass (kg)")+
    scale_x_discrete(labels = c('Carnivore','Herbivore'))+
  theme_cowplot()
```

Let's have you try creating a boxplot of the total sleep of only insectivores and omnivores. 

```{r creating a new dataframe for omnivores and insectivores}
```

```{r your boxplot of select vore and body mass}
```

#Hypothesis Testing 
Now that we have looked and explored the data above, you are going to want to check to see if the data is normal. To do this, we will be using a Shapiro-Wilk normality test. First you are going to want to create different plots of the data to look at it individually. The normal Q-Q plot should look linear.  Then we will create the Shapiro test and once you have used this command, you will look at the p-value output. If the p-value is above 0.05 it is normal, and if it is below 0.05 then the data is not normal. 

```{r Data Exploration}
#Testing body weight
simple.eda(msleep$bodywt)
shapiro.test(msleep$bodywt)
```
In this Shapiro-Wilk example, the data is not normal since the p-value of 2.2e-16 is below the 0.05 cutoff. Also, the graph of the Q-Qplot is not linear showing another example that the data is not normal. 

To fix this, you can try to use a log on the data to try to make this more linear. To do this you can create a new vector associated with log of the body weight. Then use the new vector in the same tests as you ran above. 

```{r Fixing Data Exploration}
logbodywt <- log(msleep$bodywt)
simple.eda(logbodywt)
shapiro.test(logbodywt)
```
As you can see, the log transformation was able to make the data more normal. The Q-Q plot shows a more linear graph than it did previously. Also, the p-value with the log transformation is now 0.1048 which is above the 0.05 cutoff, meaning that the data is normal. 

An important note to remember going forward is that you should continue to you the vector "logbodywt" because this uses the transformed data that is now normal rather than old data that was not normal. 

Now, you are going to test your data with a t-test, which is used to statistically tell if there is a difference in means between two different groups. If you have taken a statistics class, you have likely learned about how to do a t-test, but this will do it manually for you. 

Earlier you learned how to filter two different groups, but now you are going to filter the two groups based on the variable that you want to compare. For this example, you are comparing the the body weight of the carnivore animals compared to the body weight of the herbivore animals.

```{r t-test}
Carni <- logbodywt[msleep$vore == "carni"]
Herbi <- logbodywt[msleep$vore == "herbi"]
t.test(Carni, Herbi)
```
After running the t-test independent sample, the p number is 0.06855 which is larger than the 0.05 cutoff value. Since the p-value is larger than 0.05, this means that there is weak evidence that supports the alternative hypothesis, which is that there is a noticeable difference between the body weight of a carnivore compared to a herbivore. The carnivore average body weight was 2.664675 and the average body weight of the herbivore was 1.061476.


# Acknowledgements

Team Members: 
Sam Whittaker- Data Exploration Section 
Abby Gearhart - Hypothesis testing
Irene Hu - Introduction to R and Data Visualization



